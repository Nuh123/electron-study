# 该分支基于 b 站某 electron 系列开发视频

## 视频链接如下

<a href="https://www.bilibili.com/video/BV16f4y1q7xz" target="blank">视频链接</a>

## 主题之外

1. `code .`此命令可用于在命令行所在文件夹被 vscode 打开。
2. **命令行字符集** 可输入`chcp`来查看,**936**是 GB2312 字符集，可能存在中文乱码问题。`65001`是 utf—8。

## 概述 electron

### 最重要的概念

主进程和渲染进程，和它们之间的通信。

### 什么是 electron

略

### electron 之外的桌面应用办法

- C#的 winform
- 微软的 WPF
- java 的 swing 和 javaFX

### electron 的优势

1. 前端友好
2. 方便 B 端和 C 端的风格统一
3. 可快速开发部分效率工具

## 开发准备

### 开发工具（vscode 插件）

略

### 开发环境

略
**nmp 源以及 yarn 的问题作为 node 问题再单独研究**

## 快速开始

### 文档阅读

1. 官方文档先快速浏览一遍
2. 官方有快速开始的 demo
3. 也有和框架结合的 electron—vue

### hello world

1. 代码上的问题再对应处，基本就是官网的 demo，与 jspang 相比换汤不换药。
2. **开启开发工具函数位置不重要**视频里强调的代码开启调试工具必须在窗口加载文件之前，在目前这个版本（11.3.0）不存在该该问题。（另，可通过`ctrl + shift + i`和菜单栏开始调试工具）
3. **关闭方式和启动速度无关**视频中建议使用菜单栏`window => close`方式关闭，说直接点关闭按钮启动会，但目前测试无差异。另开发模式下可`ctrl + c`关闭，不过需要两下。
4. 关于启动命令的配置 见 package 即可。另外非配置模式下在命令行需使用`npx electron .`,electron .不好使。（node 问题，单独研究）

## 生命周期

具体以官网为主，此处可能不准，也不全，看到官网似乎有 mac 特有的一些。另疑问，为什么部分周期在控制台没输出。

1. `reday` 应用完成初始化时触发
2. `dom-ready` 文本加载完出发
3. `did-finish-load` 导航完成时触发，即选项卡旋转器停止旋转，并指派 onload 事件。
4. `window-all-closed` 所有窗口都关闭时触发
5. `before-quit` 应用关闭窗口之前触发
6. `will-quit` 所有窗口都关闭，并应用退出时触发
7. `quit` 所有窗口关闭时触发
8. `closed` 窗口关闭时触发，此阶段应删除对窗口的引用

**控制台无法输出中文问题需在控制台输入 `chcp65001`**

## 进程对象

1. **两种进程都可使用** 可用与获取系统参数，如内存、版本、进程 ID 等。继承自 node 的`process`对象，做了增强。具体见文档
2. 强调两种区别`version`和`versions`。version 是 node 版本，versions 是一系列和开发相关的版本信息。其他对象需要时再研究。

## 主进程和渲染进程

没讲个啥

我自己的理解在这边觉得还是了解浏览器的工作原理之后就能接受，一直记着的一个问题，一个 tab 页的浏览器需要四个进程。

## 文件对象

1. 使用原生 H5 的**File**对象，依赖拖拽事件**drop**，主要是拖拽事件对象中的`dataTransfer.files`对象。
2. 还看了一下原生的 drop 事件对象，发现这部分就是单纯的原生玩法。对比了下原生的 File 对象，这里证实了官网所说的**path**属性是 electron 做的增强，以供 node 使用。
3. 应该算是 electron 之外的东西，**拖拽对象**中的 files 和**文件按钮（文件上传控件）**（有点词穷）本来就是一个体系的，前者不过是从用户体验角度优化出来的新方式。
4. 那现在 electron 有**三种**可用发起本地文件操作的方式 拖拽 、 按钮、 文件选择框。

## 快捷键

略（主要是视频没有讲到什么有用的，官网也没啥新发现）

## 剪切板

1. 视频没啥讲的
2. 看了下文档，发现`clipboard`对象的 API 分为两类，**读写类** 和 **其它类**
3. 读写类通用的分为**四种**，文本、HTML、image（图片）、RTF。另 linux 不可用的 Bookamrk（书签），mac 专属的 FindText。
4. 其它类有两个比较重要的`clear()`清除方法和`availavleFormats()`支持格式方法。
5. 剩下的就是一堆不重要（可能过期）的方法，单独拎出`readBuffer`和`writeBuffer`方法，也就是说某一时期支持读写 buffer。

## webview 标签

1. 需要在主进程中开启使用，就和前面在渲染进程中使用 node 类似。需要设置`webviewTag`为 true
2. 虽然我认可作者学习的思路，但还是要说这套视频太垃圾了，真的太垃圾了，要不是有之前的时间成本在，我早就不跟了。
3. 折腾半天一看官网赫然几个大字警告**不建议使用，或用其它方案代替，或不要内嵌**
4. 不过还是有疑问，和先前接触过的**BrowserView**对象区别？暂时放弃挣扎，不做过多深究。

## shell 对象

1. 两种进程均可使用，主要功能是使用默认程序处理文件和 url
2. 具体的 API 在代码那试了一下，有些没玩起来，两个 window 平台特有的快捷方式类没玩。意外的是可以播放提示音。
3. 再 diss 这个视频作者，不是太简单不讲，就是太简单自己看。可文档有限呀。得赶紧脱离这个坑。

## remote 模块

就说了一句要在主进程中打开。

## window 对象

1. 官网那这是两个模块的内容，`window.open()`函数和`BrowserWindowProxy`，基本上还是上一套视频的内容。
2. 真是对这套视频无语，我主要是文档不全所以想通过其它方式补充。主要是太跳跃了，没有作者自己的理解，关键连官网内容都懒得阐释。感觉得调整下心态，暂时弃跟。

## BrowserWindow 对象

1. 知道几个新的知识，可以设置窗体的背景颜色,看了一下设置无框窗体。
2. 想弃跟的，但还是想快速结束吧，毕竟花了时间过过一遍了。
3. 今日新发现，**左上角图标**设置在实例化窗体时设置，具体见代码。

## BrowserView 对象

1. 与`webview`标签效果一致，一种是编码，一种是声明。特别，声明模式需要开启 webviewTag，在渲染进程使用，编码式在主进程中使用。
2. 使用上没什么特别的，就是特别注意顺序，**一定**是先将 view 对象绑定给窗口后才可以开始设置 view 对象的相关属性。
3. view 网页加载十分慢，感觉是被什么阻塞了，但应该是网页需要网络加载的锅，代码佐证。
4. BrowserView 和 BrowserWindow 的加载本地文件有不一致的体验，但目前我总结不出啥，具体效果可以通过注掉的代码实验，大概就是 view 层面的加载**无法捕捉**到右键事件。
5. 一个很摸不到头脑的问题，两种方式访问网页出现问题时完全**没任何提醒**。比如网址不可访问

## 自定义菜单栏

1. 目前没什么特殊的地方，基本和上次学的一样，甚至可以断定就是上次的例子。**强调在主进程中使用**
2. 特别注意下菜单栏自定义的操作的顺序，是先根据数据**创建模板**，再将模板**设置**为菜单栏。另外，设置方法调用时，可通过设置**null**来实现**空菜单栏**
3. 最后，通过两次调用设置菜单栏方法可以看出之前总结过的**whenReady**回调的用法。

## 右键菜单

1. 渲染进程使用，两种方式，**模板声明式** 和 **追加式**
2. 带各种预设 ‘角色’，但还不太会玩这个，也暂时没研究，被前面右键无法捕捉搞得有点烦。

## ipc 通信

1. 用于进程之间的通信，分别使用 `ipcMain` 和`ipcRenderer`，注意渲染进程中模块的名字。
2. 目前的感受就是基于**发布订阅**的两个甚至更多 `Event`，但按理说进程之间比较独立，单纯的通过 事件模式完成不了,这应该是操作系统层面的功劳了 。
3. API 比较多，但基本就是那些，比如，只触发一次，带返回值。另视频中只是'**单向的通信**'，没有解决住进程主动发起通信的情况。这里给自己留个坑，<font size=7>大坑</font>，简单搜索找到的都是'单向通信'的。

## webContent

略

## 网络

1. 类似 node 里的 **http** 模块，被 chromium 的网络库替代。
2. 视频又一顿秀操作，太简单不讲，太难不讲，没有实际意义不讲，有坑不讲。

## 渲染进程之间的通信

1. 头一次把这个写在第一个，完了，心态崩了，不跟了，还是我太菜，可能之后有时间刷完其它家的再回头来看这个吧，或者拿到他所谓的课件。
   正经内容
2. 视频中介绍的最多的应该是通过**主进程做中介**来完成。
3. 前面略掉的 webContent 应该在其中扮演的角色比较重要
4. 也有其它单纯通过 ipcRenderer 完成的。
5. 不管怎么实现这一类需求都需要注意**时机**
