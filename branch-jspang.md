# 该分支基于技术胖 electron 系列视频。

[视频地址](https://www.bilibili.com/video/BV177411s7Lt)

## electron 的介绍

略

## 开发环境的搭建

1. 前提需要安装 node 和 npm，我这 node 是**14.14.0**、npm 是**7.5.4**.
2. 安装 electron 我这跟视频一样，安装的**7.1.11**版本，倾向项目安装 `（npm i -D electron@7.1.11）`
3. 目前处于探索阶段，没有发现已知的版本之间的限制问题
4. 安装成功的标志， (项目安装) `npx electron -v` 或 `./node_modules/.bin/electron -v`弹出对应的版本号即为成功。
5. 这里试过，安装高版本的似乎没有问题，但安装 7 版本时，网络似乎有点问题，我这里不想改整个 npm 源为淘宝的，就只把项目 npm 源指向淘宝的了。（我这边 nvm 下我自己把 npm 文件挪动导致 cnpm 无法安装，所以才这么麻烦。）

## hello world

1. 基于之前的工作，目前是已经可以跑起来 electron 的，使用`./node_modules/.bin/electron`,这是一个官方的 demo。若全局安装 electron 的情况下，也可使用`electron .`或 `npx electron .`
2. 具体代码详见对应文件，main.js 为最重要的文件，里面大致为 app 加载成功后实例化窗口，该窗口可以加载指定的 html 文件显示。
3. **启动命令** 在仅项目安装 electron 下，可使用`npx electron .`,全局安装下可使用`electron .`即可。（这应该属于 node 范畴知识）这里个人觉得项目安装更为合适，全局情况下使用全局命令可能会出现依旧只出现官方 demo 情况。
4. **入口文件名问题** 目前这边采用了先初始化 npm 模式(提交上是这样)，所以需要修改 packjson 中入口为`main.js`原来是 index.js。也可以向我提交前一样，**先新建 main.js 再 npm init**。
5. **补充** 应该是是文档看到，author 和 description 对打包时必要的。且官网启动写法与该视频不一致。
   webprefer

## 基础理论知识

### 代码

这一节的代码感觉没什么用，最重要的就是 webPreferences 的使用，和 node 的使用。

### electron 运行流程

1. package.json 文件中找到入口文件，即 main 字段对应的文件，这里为 main.js。
2. main.js 即为主进程，在主进程中创建渲染进程。
3. 渲染进程读取页面和布局并显示。
4. 渲染进程使用 ipc 在主进程执行任务并获取信息。

### 名词解释

1. 主进程 这里可以粗暴的认为主进程就是 main.js。一个 electron 有且仅有一个主进程。
2. 渲染进程 这里可以粗暴的认为渲染进程就是 index.html。可以有多个渲染进程，渲染进程里也可以有 js 操作。
3. 结合上两个名词，用浏览器直观理解就是，主进程类似于浏览器这个程序，渲染进程类似于 tab 页面。主进程和渲染进程之间有点类似于线程和进程之间的关系，但他们都是进程级别的。

### 两个进程

1. 模块不通用，有些在两个进程中都能使用，有些只能在特定进程中使用。
2. 目前本节只涉及到的差别在于要在渲染进程使用 node 语法需要在实例化窗口的时候设置
3. 渲染进程中想使用主进程中的模块，必须通过 remote 模块中转。使用 remote 模块和在渲染进程中使用 node 类似，也要在主进程的`webPreferences` 的`enableRemoteModule` 为 true。

## remote 模块的使用

基本重点在上面补充了，在文档的 remote 模块就能找到说明。多余补充一点，写在代码里，看一下 remote 模块下面都有些啥，也能清晰的感觉到未开启 remote 模块前后的差距。顺便看了下主进程中有那些模块。不过两个输出的地方有些差距。这里不细究，只是了解一下，扫了眼文档，注重宽度。

## 开发工具

1. 这个无头浏览器也有调试工具，但不是 F12 开启，快捷键是 `ctrl + shift + I`，也可在菜单栏 view 项下开启。后面也会接触到代码里直接配置的方法。代码模式需要在主进程中实例化窗口后，调用窗口`webContents.openDevTools()`的方法。
2. 对于渲染进程下代码变动，可以使用 `view 菜单栏下的reloa方法`，不必每次重启，但主进程上的变动，必须重启。

## 菜单栏的自定义

1. 目前没什么需要多说的，看代码就好。至于点击事件尝试写 console，但没法实现。另外，现有实现方法存在套娃现象，没专门研究，但记得 BrowserWindow 文档部分可以写无菜单栏窗口。
2. 快捷方式，也是配置模式，但这里注意，该写法只支持 window 模式。记得之前过文档的时候看到有兼容 mac 得写法。

## 右键菜单

1. 基于 H5 的**contextMenu**事件
2. 渲染进程中使用**remote**模块
3. 与之前的菜单栏一样可以设置对应的点击事件和快捷键。
4. 右键菜单和菜单合起来看文档的 Menu 模块就行。具体右键和菜单栏的差异对比它两的方法就能看到差异，菜单栏是根据模板 build 之后 set 上去，右键是在捕捉到右键事件后 pop 到当前窗口。

## 浏览器中打开网页

1. 在渲染进程中打开 a 标签，默认是在当前**应用窗口**打开。即使设置了 target，也是在**新的应用窗口**打开。
2. 借助**shell**模块，可以在浏览器中打开，具体代码见对应处。
3. shell 模块在文档的描述应该是使用默认程序打开，不过此处没有细究。

## 嵌入网页

1. 嵌入网页类似于在网页中使用 ifram
2. 需要使用`BrowserView`模块，是**主进程**中的模块
3. `BrowserView`与`Browserwindow`类似，不过 view 需要依赖 window 存在，具体差别看代码处。
4. 一个现象，BrowserView 的层级似乎比控制台的高，导致窗口宽度不够时，控制台被覆盖。

## 打开子窗口

1. 使用`window.open()`即可，具体看代码。
2. 这里的重点在于`window.open()`和`new BrowserWindow()`的区别，前者打开的是有隶属关系的，后者是没有的。但这个隶属关系似乎在用户行为层面没有啥差别。
3. 目前只了解到这些，有待后期拓展。

## 向父窗口传递信息

1. 使用 `window.opener.postMessage(msg,targetOrigin)`API 其中**msg**指要传递的信息，**targetOrigin** 指消息接收方 window.opener()指当前窗口的**父窗口们**（这句存疑，需验证），不指定消息接受方则发送给所有父窗口。
2. 具体使用见代码
3. 视频里没讲的，反过来父窗口向子窗口传递也可以用类似的 API，只不过应该是使用 window.open 打开的窗口作为接收方（这句存疑，需验证）。
4. 具体的使用还是得看 window 对象的文档。

## 文件选择对话框

1. API 是`dialog.showOpenDialog()`,其中两个参数，第一个是窗口设置(具体格式见代码或官方文档)，第二个是**回调函数**,是 then 形式。
2. dialog 是主线程模块，也就是需要使用 **remote**

## 保存对话框

1. 和文件选择对话框类似 API 为 `dialog.showSaveDialog()`参数形式也一样。
