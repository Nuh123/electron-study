# 该分支基于技术胖electron系列视频。

[视频地址](https://www.bilibili.com/video/BV177411s7Lt)


## electron的介绍

 略

## 开发环境的搭建 

1. 前提需要安装node和npm，我这node是**14.14.0**、npm是**7.5.4**.
2. 安装electron 我这跟视频一样，安装的**7.1.11**版本，倾向项目安装 `（npm i -D electron@7.1.11）`
3. 目前处于探索阶段，没有发现已知的版本之间的限制问题
4. 安装成功的标志， (项目安装) `npx electron -v`  或 `./node_modules/.bin/electron -v`弹出对应的版本号即为成功。
5. 这里试过，安装高版本的似乎没有问题，但安装7版本时，网络似乎有点问题，我这里不想改整个npm源为淘宝的，就只把项目npm源指向淘宝的了。（我这边nvm下我自己把npm文件挪动导致cnpm无法安装，所以才这么麻烦。）


## hello world 

1. 基于之前的工作，目前是已经可以跑起来electron的，使用`./node_modules/.bin/electron`,这是一个官方的demo。若全局安装electron的情况下，也可使用`electron .`或 `npx electron .`
2. 具体代码详见对应文件，main.js为最重要的文件，里面大致为app加载成功后实例化窗口，该窗口可以加载指定的html文件显示。
3. **启动命令** 在仅项目安装electron下，可使用`npx electron .`,全局安装下可使用`electron .`即可。（这应该属于node范畴知识）这里个人觉得项目安装更为合适，全局情况下使用全局命令可能会出现依旧只出现官方demo情况。
4. **入口文件名问题** 目前这边采用了先初始化npm模式(提交上是这样)，所以需要修改packjson中入口为`main.js`原来是index.js。也可以向我提交前一样，**先新建main.js再npm init**。
5. **补充** 应该是是文档看到，author和description对打包时必要的。且官网启动写法与该视频不一致。
webprefer
## 基础理论知识

### 代码
 这一节的代码感觉没什么用，最重要的就是webPreferences的使用，和node 的使用。

### electron运行流程
1. package.json 文件中找到入口文件，即main字段对应的文件，这里为main.js。
2. main.js 即为主进程，在主进程中创建渲染进程。
3. 渲染进程读取页面和布局并显示。
4. 渲染进程使用ipc在主进程执行任务并获取信息。

### 名词解释
1. 主进程  这里可以粗暴的认为主进程就是main.js。一个electron有且仅有一个主进程。
2. 渲染进程 这里可以粗暴的认为渲染进程就是index.html。可以有多个渲染进程，渲染进程里也可以有js操作。
3. 结合上两个名词，用浏览器直观理解就是，主进程类似于浏览器这个程序，渲染进程类似于tab页面。主进程和渲染进程之间有点类似于线程和进程之间的关系，但他们都是进程级别的。

### 两个进程

1. 模块不通用，有些在两个进程中都能使用，有些只能在特定进程中使用。
2. 目前本节只涉及到的差别在于要在渲染进程使用node语法需要在实例化窗口的时候设置
3. 渲染进程中想使用主进程中的模块，必须通过remote模块中转。使用remote模块和在渲染进程中使用node类似，也要在主进程的`webPreferences` 的`enableRemoteModule` 为true。

## remote 模块的使用

基本重点在上面补充了，在文档的remote模块就能找到说明。多余补充一点，写在代码里，看一下remote模块下面都有些啥，也能清晰的感觉到未开启remote模块前后的差距。顺便看了下主进程中有那些模块。不过两个输出的地方有些差距。这里不细究，只是了解一下，扫了眼文档，注重宽度。

## 开发工具

1. 这个无头浏览器也有调试工具，但不是F12开启，快捷键是 `ctrl + shift + I`，也可在菜单栏view项下开启。后面也会接触到代码里直接配置的方法。代码模式需要在主进程中实例化窗口后，调用窗口`webContents.openDevTools()`的方法。
2. 对于渲染进程下代码变动，可以使用 `view 菜单栏下的reloa方法`，不必每次重启，但主进程上的变动，必须重启。

## 菜单栏的自定义

1. 目前没什么需要多说的，看代码就好。至于点击事件尝试写console，但没法实现。另外，现有实现方法存在套娃现象，没专门研究，但记得BrowserWindow文档部分可以写无菜单栏窗口。
2. 快捷方式，也是配置模式，但这里注意，该写法只支持window模式。记得之前过文档的时候看到有兼容mac得写法。

## 右键菜单

1. 基于H5的**contextMenu**事件
2. 渲染进程中使用**remote**模块
3. 与之前的菜单栏一样可以设置对应的点击事件和快捷键。
4. 右键菜单和菜单合起来看文档的Menu模块就行。具体右键和菜单栏的差异对比它两的方法就能看到差异，菜单栏是根据模板build之后set上去，右键是在捕捉到右键事件后pop到当前窗口。

## 浏览器中打开网页

1. 在渲染进程中打开a标签，默认是在当前**应用窗口**打开。即使设置了target，也是在**新的应用窗口**打开。
2. 借助**shell**模块，可以在浏览器中打开，具体代码见对应处。
3. shell模块在文档的描述应该是使用默认程序打开，不过此处没有细究。

## 嵌入网页

1. 嵌入网页类似于在网页中使用ifram
2. 需要使用`BrowserView`模块，是**主进程**中的模块
3. `BrowserView`与`Browserwindow`类似，不过view需要依赖window存在，具体差别看代码处。
4. 一个现象，BrowserView的层级似乎比控制台的高，导致窗口宽度不够时，控制台被覆盖。

## 打开子窗口

1. 使用`window.open()`即可，具体看代码。
2. 这里的重点在于`window.open()`和`new BrowserWindow()`的区别，前者打开的是有隶属关系的，后者是没有的。但这个隶属关系似乎在用户行为层面没有啥差别。
3. 目前只了解到这些，有待后期拓展。

## 向父窗口传递信息

1. 使用 `window.opener.postMessage(msg,targetOrigin)`API 其中**msg**指要传递的信息，**targetOrigin** 指消息接收方window.opener()指当前窗口的**父窗口们**（这句存疑，需验证），不指定消息接受方则发送给所有父窗口。
2. 具体使用见代码
3. 视频里没讲的，反过来父窗口向子窗口传递也可以用类似的API，只不过应该是使用window.open打开的窗口作为接收方（这句存疑，需验证）。
4. 具体的使用还是得看window对象的文档。